#include "oled.h"
#include "i2c.h"

// ASCII字体库 6x8 (仅包含基本ASCII字符，每个字符6个字节)
static const uint8_t OLED_FONT_6X8[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 空格
    0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, // $
    0x23, 0x13, 0x08, 0x64, 0x62, 0x00, // %
    0x36, 0x49, 0x56, 0x20, 0x50, 0x00, // &
    0x00, 0x08, 0x07, 0x03, 0x00, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, // )
    0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x00, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, // +
    0x00, 0x80, 0x70, 0x30, 0x00, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, // -
    0x00, 0x00, 0x60, 0x60, 0x00, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, 0x00, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, 0x00, // 2
    0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, 0x00, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, // 6
    0x01, 0x71, 0x09, 0x05, 0x03, 0x00, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, 0x00, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, // 9
    0x00, 0x36, 0x36, 0x00, 0x00, 0x00, // :
    0x00, 0x56, 0x36, 0x00, 0x00, 0x00, // ;
    0x08, 0x14, 0x22, 0x41, 0x00, 0x00, // <
    0x14, 0x14, 0x14, 0x14, 0x14, 0x00, // =
    0x00, 0x41, 0x22, 0x14, 0x08, 0x00, // >
    0x02, 0x01, 0x51, 0x09, 0x06, 0x00, // ?
    0x32, 0x49, 0x59, 0x51, 0x3E, 0x00, // @
    0x7C, 0x12, 0x11, 0x12, 0x7C, 0x00, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, // C
    0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, // E
    0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, // F
    0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, // L
    0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, // R
    0x46, 0x49, 0x49, 0x49, 0x31, 0x00, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, // V
    0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, // W
    0x63, 0x14, 0x08, 0x14, 0x63, 0x00, // X
    0x07, 0x08, 0x70, 0x08, 0x07, 0x00, // Y
    0x61, 0x51, 0x49, 0x45, 0x43, 0x00, // Z
    0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, // [
    0x55, 0xAA, 0x55, 0xAA, 0x55, 0x00, // 反斜杠(保留)
    0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, // ]
    0x04, 0x02, 0x01, 0x02, 0x04, 0x00, // ^
    0x40, 0x40, 0x40, 0x40, 0x40, 0x00, // _
    0x00, 0x01, 0x02, 0x04, 0x00, 0x00, // `
    0x20, 0x54, 0x54, 0x54, 0x78, 0x00, // a
    0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, // b
    0x38, 0x44, 0x44, 0x44, 0x20, 0x00, // c
    0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, // d
    0x38, 0x54, 0x54, 0x54, 0x18, 0x00, // e
    0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, // f
    0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, // g
    0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, // h
    0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, // i
    0x40, 0x80, 0x84, 0x7D, 0x00, 0x00, // j
    0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, // k
    0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, // l
    0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, // m
    0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, // n
    0x38, 0x44, 0x44, 0x44, 0x38, 0x00, // o
    0xFC, 0x24, 0x24, 0x24, 0x18, 0x00, // p
    0x18, 0x24, 0x24, 0x18, 0xFC, 0x00, // q
    0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, // r
    0x48, 0x54, 0x54, 0x54, 0x20, 0x00, // s
    0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, // t
    0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, // u
    0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, // v
    0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, // w
    0x44, 0x28, 0x10, 0x28, 0x44, 0x00, // x
    0x1C, 0xA0, 0xA0, 0xA0, 0x7C, 0x00, // y
    0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, // z
    0x00, 0x08, 0x36, 0x41, 0x00, 0x00, // {
    0x00, 0x00, 0x77, 0x00, 0x00, 0x00, // |
    0x00, 0x41, 0x36, 0x08, 0x00, 0x00, // }
    0x02, 0x01, 0x02, 0x04, 0x02, 0x00, // ~
};

// 当前光标位置
static uint8_t OLED_CurrentRow = 0;
static uint8_t OLED_CurrentCol = 0;

// OLED显示缓冲区，用于实现滚动功能 (存储当前屏幕上的文本)
static char OLED_Buffer[OLED_MAX_ROWS][OLED_MAX_COLS+1];  // +1 用于字符串结束符'\0'

/**
 * @brief 向OLED发送一个命令
 * @param command 命令值
 */
static void OLED_Write_Command(uint8_t command) {
    uint8_t data[2] = {0x00, command};  // 0x00表示命令
    HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDRESS, data, 2, 100);
}

/**
 * @brief 向OLED发送数据
 * @param data 数据值
 */
static void OLED_Write_Data(uint8_t data) {
    uint8_t buf[2] = {0x40, data};  // 0x40表示数据
    HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDRESS, buf, 2, 100);
}

/**
 * @brief 初始化OLED
 */
void OLED_Init(void) {
    // 等待OLED上电稳定
    HAL_Delay(100);
    
    // 发送初始化命令序列
    OLED_Write_Command(OLED_CMD_SET_DISP_OFF);           // 0xAE 关闭显示
    OLED_Write_Command(OLED_CMD_SET_DISP_CLK_DIV);       // 0xD5 设置时钟分频
    OLED_Write_Command(0x80);                            // 默认值
    OLED_Write_Command(OLED_CMD_SET_MULTIPLEX_RATIO);    // 0xA8 设置复用率
    OLED_Write_Command(0x3F);                            // 63 (64-1)
    OLED_Write_Command(OLED_CMD_SET_DISP_OFFSET);        // 0xD3 设置显示偏移
    OLED_Write_Command(0x00);                            // 无偏移
    OLED_Write_Command(OLED_CMD_SET_DISP_START_LINE);    // 0x40 设置起始行为0
    OLED_Write_Command(OLED_CMD_SET_SEGMENT_REMAP_1);    // 0xA1 段重映射，列地址 0 映射到 SEG127
    OLED_Write_Command(OLED_CMD_SET_COM_SCAN_DIR_REMAP); // 0xC8 行扫描方向翻转
    OLED_Write_Command(OLED_CMD_SET_COM_PINS_HW_CONFIG); // 0xDA 设置COM引脚硬件配置
    OLED_Write_Command(0x12);                            // 交替COM配置，使能COM左/右重映射
    OLED_Write_Command(OLED_CMD_SET_CONTRAST);           // 0x81 设置对比度
    OLED_Write_Command(0xCF);                            // 设置对比度为较高值
    OLED_Write_Command(OLED_CMD_SET_PRECHARGE_PERIOD);   // 0xD9 设置预充电周期
    OLED_Write_Command(0xF1);                            // 设置周期15循环
    OLED_Write_Command(OLED_CMD_SET_VCOMH_DESELECT_LVL); // 0xDB 设置VCOMH电平
    OLED_Write_Command(0x40);                            // 设置VCOMH电平
    OLED_Write_Command(OLED_CMD_ENTIRE_DISP_OFF);        // 0xA4 禁止全显
    OLED_Write_Command(OLED_CMD_SET_NORMAL_DISP);        // 0xA6 正常显示（非反显）
    OLED_Write_Command(OLED_CMD_SET_MEM_ADDR_MODE);      // 0x20 设置内存寻址模式
    OLED_Write_Command(0x00);                            // 水平寻址模式

    // 清屏
    OLED_Clear();

    // 初始化内存缓冲区
    for (uint8_t i = 0; i < OLED_MAX_ROWS; i++) {
        memset(OLED_Buffer[i], ' ', OLED_MAX_COLS);
        OLED_Buffer[i][OLED_MAX_COLS] = '\0';
    }

    // 打开显示
    OLED_Display_On();
}

/**
 * @brief 清除屏幕
 */
void OLED_Clear(void) {
    uint8_t i, j;
    for (i = 0; i < 8; i++) {
        OLED_Write_Command(0xB0 + i);    // 设置页地址（0~7）
        OLED_Write_Command(0x00);        // 设置列低地址
        OLED_Write_Command(0x10);        // 设置列高地址
        
        // 清除整个页
        for (j = 0; j < 128; j++) {
            OLED_Write_Data(0x00);
        }
    }
    
    // 重置光标位置
    OLED_CurrentRow = 0;
    OLED_CurrentCol = 0;
    
    // 清除缓冲区
    for (uint8_t i = 0; i < OLED_MAX_ROWS; i++) {
        memset(OLED_Buffer[i], ' ', OLED_MAX_COLS);
        OLED_Buffer[i][OLED_MAX_COLS] = '\0';
    }
}

/**
 * @brief 开启OLED显示
 */
void OLED_Display_On(void) {
    OLED_Write_Command(OLED_CMD_SET_DISP_ON);   // 0xAF
}

/**
 * @brief 关闭OLED显示
 */
void OLED_Display_Off(void) {
    OLED_Write_Command(OLED_CMD_SET_DISP_OFF);  // 0xAE
}

/**
 * @brief 设置显示光标位置
 * @param x 列位置（像素）
 * @param y 页位置（0-7）
 */
void OLED_Set_Pos(uint8_t x, uint8_t y) {
    OLED_Write_Command(0xB0 + y);
    OLED_Write_Command(((x & 0xF0) >> 4) | 0x10);
    OLED_Write_Command(x & 0x0F);
}

/**
 * @brief 写入一个字符
 * @param chr 要显示的字符
 */
void OLED_Write_Char(char chr) {
    uint8_t c = 0;
    
    // 处理换行符
    if (chr == '\n' || OLED_CurrentCol >= OLED_MAX_COLS) {
        OLED_CurrentRow++;
        OLED_CurrentCol = 0;
        
        // 如果超出屏幕底部，则滚动
        if (OLED_CurrentRow >= OLED_MAX_ROWS) {
            OLED_Scroll_Up();
            OLED_CurrentRow = OLED_MAX_ROWS - 1;
        }
        
        if (chr == '\n') {
            return;
        }
    }
    
    // 确定字符的ASCII码值并获取字体数据
    if (chr >= ' ' && chr <= '~') {
        c = chr - ' ';
    } else {
        c = 0; // 显示空格
    }
    
    // 更新缓冲区
    OLED_Buffer[OLED_CurrentRow][OLED_CurrentCol] = chr;
    
    // 计算像素位置
    uint8_t pos_x = OLED_CurrentCol * OLED_CHAR_WIDTH;
    uint8_t pos_y = OLED_CurrentRow;
    
    // 设置显示位置
    OLED_Set_Pos(pos_x, pos_y);
    
    // 写入字符数据
    for (uint8_t i = 0; i < OLED_CHAR_WIDTH; i++) {
        OLED_Write_Data(OLED_FONT_6X8[c * OLED_CHAR_WIDTH + i]);
    }
    
    // 更新光标位置
    OLED_CurrentCol++;
}

/**
 * @brief 显示字符串
 * @param x 起始列位置（像素）
 * @param y 页位置（0-7）
 * @param str 要显示的字符串
 */
void OLED_Write_String(uint8_t x, uint8_t y, const char *str) {
    // 设置当前位置
    OLED_CurrentRow = y;
    OLED_CurrentCol = x / OLED_CHAR_WIDTH;
    
    // 显示每个字符
    while (*str != '\0') {
        OLED_Write_Char(*str++);
    }
}

/**
 * @brief 设置光标位置
 * @param row 行位置（0-7）
 * @param col 列位置（0-20）
 */
void OLED_Set_Cursor(uint8_t row, uint8_t col) {
    if (row < OLED_MAX_ROWS && col < OLED_MAX_COLS) {
        OLED_CurrentRow = row;
        OLED_CurrentCol = col;
    }
}

/**
 * @brief 屏幕向上滚动一行
 */
void OLED_Scroll_Up(void) {
    // 移动缓冲区内容
    for (uint8_t i = 0; i < OLED_MAX_ROWS - 1; i++) {
        memcpy(OLED_Buffer[i], OLED_Buffer[i+1], OLED_MAX_COLS);
    }
    
    // 清除最后一行
    memset(OLED_Buffer[OLED_MAX_ROWS-1], ' ', OLED_MAX_COLS);
    OLED_Buffer[OLED_MAX_ROWS-1][OLED_MAX_COLS] = '\0';
    
    // 重新显示所有内容
    for (uint8_t i = 0; i < OLED_MAX_ROWS; i++) {
        OLED_Set_Pos(0, i);
        for (uint8_t j = 0; j < OLED_MAX_COLS; j++) {
            char c = OLED_Buffer[i][j];
            if (c >= ' ' && c <= '~') {
                for (uint8_t k = 0; k < OLED_CHAR_WIDTH; k++) {
                    OLED_Write_Data(OLED_FONT_6X8[(c - ' ') * OLED_CHAR_WIDTH + k]);
                }
            } else {
                for (uint8_t k = 0; k < OLED_CHAR_WIDTH; k++) {
                    OLED_Write_Data(0x00);
                }
            }
        }
    }
}

/**
 * @brief 类似printf的格式化输出函数
 * @param format 格式化字符串
 * @param ... 可变参数
 */
void OLED_Printf(const char *format, ...) {
    char buffer[128];  // 缓冲区大小，可根据需要调整
    va_list args;
    
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);
    
    // 显示格式化后的字符串
    char *ptr = buffer;
    while (*ptr != '\0') {
        OLED_Write_Char(*ptr++);
    }
}